/**
 * Test vectors verification.
 *
 * These tests verify that the TypeScript SDK produces the same order hashes
 * as the Rust signet-types crate. The test vectors are generated by running:
 *
 * cargo t -p signet-types serialization_vectors -- --nocapture
 */
import { describe, expect, it } from "vitest";
import type { Address, Hex } from "viem";
import { orderHash, orderHashPreImage } from "../src/signing/hash.js";
import type { SignedOrder } from "../src/types/order.js";
import vectors from "./vectors.json";

/**
 * Serialized test vector from Rust.
 */
interface SerializedVector {
  name: string;
  expectedOrderHash: Hex;
  expectedOrderHashPreImage: Hex;
  signedOrder: {
    outputs: Array<{
      token: Address;
      amount: Hex;
      recipient: Address;
      chainId: number;
    }>;
    owner: Address;
    permit: {
      deadline: Hex;
      nonce: Hex;
      permitted: Array<{
        token: Address;
        amount: Hex;
      }>;
    };
    signature: Hex;
  };
}

/**
 * Parse a serialized vector into a SignedOrder.
 */
function parseVector(v: SerializedVector): SignedOrder {
  return {
    permit: {
      permit: {
        permitted: v.signedOrder.permit.permitted.map((p) => ({
          token: p.token,
          amount: BigInt(p.amount),
        })),
        nonce: BigInt(v.signedOrder.permit.nonce),
        deadline: BigInt(v.signedOrder.permit.deadline),
      },
      owner: v.signedOrder.owner,
      signature: v.signedOrder.signature,
    },
    outputs: v.signedOrder.outputs.map((o) => ({
      token: o.token,
      amount: BigInt(o.amount),
      recipient: o.recipient,
      chainId: o.chainId,
    })),
  };
}

describe("order hash verification", () => {
  const testVectors = vectors as SerializedVector[];

  for (const v of testVectors) {
    describe(v.name, () => {
      const order = parseVector(v);

      it("produces correct order hash", () => {
        const hash = orderHash(order);
        expect(hash.toLowerCase()).toBe(v.expectedOrderHash.toLowerCase());
      });

      it("produces correct order hash pre-image", () => {
        const preImage = orderHashPreImage(order);
        expect(preImage.toLowerCase()).toBe(
          v.expectedOrderHashPreImage.toLowerCase()
        );
      });
    });
  }
});

describe("specific test cases", () => {
  it("minimal order hash matches expected", () => {
    const order: SignedOrder = {
      permit: {
        permit: {
          permitted: [
            {
              token: "0x0000000000000000000000000000000000000000",
              amount: 0n,
            },
          ],
          nonce: 0n,
          deadline: 0n,
        },
        owner: "0x0000000000000000000000000000000000000000",
        signature:
          "0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000021b",
      },
      outputs: [
        {
          token: "0x0000000000000000000000000000000000000000",
          amount: 0n,
          recipient: "0x0000000000000000000000000000000000000000",
          chainId: 0,
        },
      ],
    };

    const hash = orderHash(order);
    expect(hash.toLowerCase()).toBe(
      "0x33ed1473731924de70307a7b458dab12b27c9354ca49d18d84511f6b84e5c956"
    );
  });

  it("handles large amounts exceeding JS safe integer", () => {
    const order: SignedOrder = {
      permit: {
        permit: {
          permitted: [
            {
              token: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
              amount: 10_000_000_000_000_000_000_000n, // 10,000 ETH
            },
          ],
          nonce: BigInt("0xffffffffffffffff"), // u64::MAX
          deadline: BigInt("0xffffffffffffffff"), // u64::MAX
        },
        owner: "0x5555555555555555555555555555555555555555",
        signature:
          "0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000021b",
      },
      outputs: [
        {
          token: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
          amount: 10_000_000_000_000_000_000_000n,
          recipient: "0x6666666666666666666666666666666666666666",
          chainId: 1,
        },
      ],
    };

    const hash = orderHash(order);
    expect(hash.toLowerCase()).toBe(
      "0x7401ff93a0f4d16b66cc5a51109808f6bb29560cce8d0d3e1fce44edc8474e27"
    );
  });

  it("handles cross-chain outputs", () => {
    const order: SignedOrder = {
      permit: {
        permit: {
          permitted: [
            {
              token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
              amount: 5_000_000n, // 5 USDC
            },
          ],
          nonce: 777n,
          deadline: 1750000000n,
        },
        owner: "0xcafebabecafebabecafebabecafebabecafebabe",
        signature:
          "0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000021b",
      },
      outputs: [
        {
          token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
          amount: 2_500_000n,
          recipient: "0x4444444444444444444444444444444444444444",
          chainId: 1, // Mainnet
        },
        {
          token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
          amount: 2_500_000n,
          recipient: "0x4444444444444444444444444444444444444444",
          chainId: 421614, // Arbitrum Sepolia
        },
      ],
    };

    const hash = orderHash(order);
    expect(hash.toLowerCase()).toBe(
      "0x807d54b20e040acefab926751bab0f64e0e97932b6931983b4961db074df0329"
    );
  });
});
