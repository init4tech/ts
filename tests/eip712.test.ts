/**
 * EIP-712 signing hash verification tests.
 *
 * These tests verify that the TypeScript SDK computes the same EIP-712
 * domain separator, struct hash, and signing hash as the Rust implementation.
 *
 * The test vectors are generated by running:
 * cargo t -p signet-types eip712_signing_vectors -- --nocapture
 */
import { describe, expect, it } from "vitest";
import type { Address, Hex } from "viem";
import {
  eip712Components,
  eip712SigningHash,
  permit2DomainSeparator,
  permitBatchWitnessStructHash,
} from "../src/signing/eip712.js";
import type { Eip712SigningParams } from "../src/signing/eip712.js";
import vectors from "./eip712-vectors.json";

/**
 * Serialized test vector from Rust.
 */
interface SerializedVector {
  name: string;
  chain_id: number;
  order_contract: Address;
  permitted: Array<{
    token: Address;
    amount: Hex;
  }>;
  nonce: Hex;
  deadline: Hex;
  outputs: Array<{
    token: Address;
    amount: Hex;
    recipient: Address;
    chain_id: number;
  }>;
  expected_domain_separator: Hex;
  expected_struct_hash: Hex;
  expected_signing_hash: Hex;
}

/**
 * Parse a serialized vector into Eip712SigningParams.
 */
function parseVector(v: SerializedVector): Eip712SigningParams {
  return {
    chainId: BigInt(v.chain_id),
    orderContract: v.order_contract,
    permitted: v.permitted.map((p) => ({
      token: p.token,
      amount: BigInt(p.amount),
    })),
    nonce: BigInt(v.nonce),
    deadline: BigInt(v.deadline),
    outputs: v.outputs.map((o) => ({
      token: o.token,
      amount: BigInt(o.amount),
      recipient: o.recipient,
      chainId: o.chain_id,
    })),
  };
}

describe("EIP-712 signing hash verification", () => {
  const testVectors = vectors as SerializedVector[];

  for (const v of testVectors) {
    describe(v.name, () => {
      const params = parseVector(v);

      it("produces correct domain separator", () => {
        const domainSep = permit2DomainSeparator(params.chainId);
        expect(domainSep.toLowerCase()).toBe(
          v.expected_domain_separator.toLowerCase()
        );
      });

      it("produces correct struct hash", () => {
        const structHash = permitBatchWitnessStructHash(params);
        expect(structHash.toLowerCase()).toBe(
          v.expected_struct_hash.toLowerCase()
        );
      });

      it("produces correct signing hash", () => {
        const signingHash = eip712SigningHash(params);
        expect(signingHash.toLowerCase()).toBe(
          v.expected_signing_hash.toLowerCase()
        );
      });

      it("eip712Components returns all correct values", () => {
        const components = eip712Components(params);
        expect(components.domainSeparator.toLowerCase()).toBe(
          v.expected_domain_separator.toLowerCase()
        );
        expect(components.structHash.toLowerCase()).toBe(
          v.expected_struct_hash.toLowerCase()
        );
        expect(components.signingHash.toLowerCase()).toBe(
          v.expected_signing_hash.toLowerCase()
        );
      });
    });
  }
});

describe("specific EIP-712 test cases", () => {
  it("mainnet Permit2 domain separator is correct", () => {
    const domainSep = permit2DomainSeparator(1n);
    // Known mainnet Permit2 domain separator
    expect(domainSep.toLowerCase()).toBe(
      "0x866a5aba21966af95d6c7ab78eb2b2fc913915c28be3b9aa07cc04ff903e3f28"
    );
  });

  it("rollup (519) Permit2 domain separator is correct", () => {
    const domainSep = permit2DomainSeparator(519n);
    expect(domainSep.toLowerCase()).toBe(
      "0xb9763ec6fa56d573bb57683efe8980ae88b28d02923686476e9f03012cf86930"
    );
  });

  it("minimal signing hash matches expected", () => {
    const params: Eip712SigningParams = {
      chainId: 1n,
      orderContract: "0x0000000000000000000000000000000000000000",
      permitted: [
        {
          token: "0x0000000000000000000000000000000000000000",
          amount: 0n,
        },
      ],
      nonce: 0n,
      deadline: 0n,
      outputs: [
        {
          token: "0x0000000000000000000000000000000000000000",
          amount: 0n,
          recipient: "0x0000000000000000000000000000000000000000",
          chainId: 0,
        },
      ],
    };

    const signingHash = eip712SigningHash(params);
    expect(signingHash.toLowerCase()).toBe(
      "0x4c8eb855427d98f29425e966e3d7526f9ed6b787a23895d12069f939fd21cc07"
    );
  });

  it("handles large amounts exceeding JS safe integer", () => {
    const params: Eip712SigningParams = {
      chainId: 1n,
      orderContract: "0x96f44ddc3bc8892371305531f1a6d8ca2331fe6c",
      permitted: [
        {
          token: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
          amount: 10_000_000_000_000_000_000_000n, // 10,000 ETH
        },
      ],
      nonce: BigInt("0xffffffffffffffff"), // u64::MAX
      deadline: BigInt("0xffffffffffffffff"), // u64::MAX
      outputs: [
        {
          token: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
          amount: 10_000_000_000_000_000_000_000n,
          recipient: "0x5555555555555555555555555555555555555555",
          chainId: 1,
        },
      ],
    };

    const signingHash = eip712SigningHash(params);
    expect(signingHash.toLowerCase()).toBe(
      "0xa7302e15c4eea4c3226c73af6c95d1641e42e23e466ea4a67c88555e224891c6"
    );
  });

  it("handles multiple outputs", () => {
    const params: Eip712SigningParams = {
      chainId: 519n,
      orderContract: "0x000000000000007369676e65742d6f7264657273",
      permitted: [
        {
          token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
          amount: 5_000_000n,
        },
      ],
      nonce: 999999n,
      deadline: 1800000000n,
      outputs: [
        {
          token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
          amount: 2_500_000n,
          recipient: "0x1111111111111111111111111111111111111111",
          chainId: 1,
        },
        {
          token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
          amount: 2_500_000n,
          recipient: "0x2222222222222222222222222222222222222222",
          chainId: 519,
        },
      ],
    };

    const signingHash = eip712SigningHash(params);
    expect(signingHash.toLowerCase()).toBe(
      "0xcbb98baeac6cc33d54613eff26f961554ef5af8873905e1fc320d1cb8883bc3d"
    );
  });
});
